Question 1

Step 1: simpledb.Parser.main() and simpledb.Parser.start()

simpledb.Parser.main() is the entry point for the SimpleDB system. It calls simpledb.Parser.start(). The latter performs three main actions:
- It populates the SimpleDB catalog from the catalog text file provided by the user as argument (Database.getCatalog().loadSchema(argv[0]);).
- For each table defined in the system catalog, it computes statistics over the data in the table by calling: TableStats.computeStatistics(), which then does: TableStats s = new TableStats(tableid, IOCOSTPERPAGE);
- It processes the statements submitted by the user (processNextStatement(new ByteArrayInputStream(statementBytes));)

Step 2: simpledb.Parser.processNextStatement()

This method takes two key actions:
- First, it gets a physical plan for the query by invoking handleQueryStatement((ZQuery)s);
- Then it executes the query by calling query.execute();

Step 3: simpledb.Parser.handleQueryStatement()

- This method first calls parseQueryLogicalPlan(tId, (ZQuery)s) to get the logical plan for the query. 
- Then, it tries to get a physical plan from the logical plan by calling LogicalPlan.physicalPlan(tId, TableStats.getStatsMap(), explain). If there exists a physical plan, then it invokes OperatorCardinality.updateOperatorCardinality

Step 4: simpledb.Parser.parseQueryLogicalPlan()

- First, walks through tables in the FROM clause if they exist, adding each as a scan to the logical plan.
- Second, parses the WHERE clause by calling processExpression()
- Third, checks for GROUP BY fields, at most one is present
- Fourth, walks through SELECT list, picks out aggregates, and checks for query validity. If aggregates are valid, they're added to the logical plan
- Fifth, sorts the data, getting ORDER BY if exists. 

Step 5: simpledb.Parser.processExpression()

- simpledb.Parser.processExpression() processes the WHERE clauses of the query, creating filter/join nodes if necessary. If there are nested subqueries, it process the subqueries as regular queries. Filter/join nodes are added to the logical plan if they exist.

Step 6: simpledb.LogicalPlan.physicalPlan()

simpledb.LogicalPlan.physicalPlan() converts the logical plan into a physical plan by returning a DbIterator representing the plan.
- First, it loops through all the tables represented in the query and sets default selectivity of 1.0, e.g. a full table scan, for each.
- Second, for each filter in the query, it determines the affected fields and updates the selectivity for that field's TableStats by calling s.estimateSelectivity(subplan.getTupleDesc().fieldNameToIndex(lf.fieldQuantifiedName), lf.p, f);
- Third, it finds the optimal join orders by calling JoinOptimizer.orderJoins(statsMap,filterSelectivities,explain).
- Fourth, using this order, it carries out the join operation which results in a DbIterator of joined tuples.
- Finally, it goes through the select fields to figure out which fields to include in the final projection, taking into account aggregates and sorting order.

Step 7: simpledb.TableStats.estimateSelectivity()

- This method figures out the type of the predicate field, and calls the corresponding histogram function to estimate the selectivity of the predicate on that field.
- It calls either IntHistogram.estimateSelectivity(op, val) or StringHistogram.estimateSelectivity(op, val).

Step 8: simpledb.IntHistogram.estimateSelectivity() or simpledb.StringHistogram.estimateSelectivity()

- This method takes the predicate and the field and returns an estimate of the fraction of elements within the tuples of the table that are needed to determine the answer to the operation.

Step 9: simpledb.JoinOptimizer.orderJoins()

This method computes and returns the best order of joins that results in the most optimal plan.
- It computes subsets of size starting from 1 to joins.size() and loops through each subset. Within each subset, it loops through each node and computes the best way to join the node with the rest of the subset by calling computeCostAndCardOfSubplan(stats, filterSelectivities, node, subset, best.cost, pc);
- For each iterated node, it checks the cost and if its the cheapest join so far, it records the information in the PlanCache for subsets of its size + 1 to easily reference in its computation.

Step 10: simpledb.JoinOptimizer.computeCostAndCardOfSubplan()

This method computes the cheapest way to join a node and the rest of the subset it belongs to, or null if no such linear joining is possible or cheaper than the best it has found.
- This method first computes the table costs and cardinalities for the two tables that are to be joined when compared to the best ordering so far.
- It then finds the join cost for both the current ordering and swapped table ordering by calling estimateJoinCost(j, t1card, t2card, t1cost, t2cost) and estimateJoinCost(j2, t1card, t2card, t1cost, t2cost) and selects the lower cost one.
- Finally, if the join cost is the best one it has found so far, it records the cardinality of the resulting join by calling estimateJoinCardinality(j, t1card, t2card, leftPkey, rightPkey, stats), the cost and plan in a CostCard object, then returned.

Step 11: simpledb.JoinOptimizer.estimateJoinCost()

This function simply calculates the estimated cost of a join between the two tables given each table's scan cost and cardinality.
- In this project, the estimate comes from adding the IO cost of the nested loops join and an additional CPU cost for processing each tuple.

Step 12: simpledb.JoinOptimizer.estimateJoinCardinality()

This function estimates the number of tuples produced by joining the two tables, given the individual table cardinalities and whether fields are primary/unique keys.
- For equality join operations, it simply returns the larger cardinality.
- For ranged join operations, it uses the heuristic of returning the number which is 30% of the number of tuples produced by the cross-product of the two tables.


Question 6.1

The query plan our optimizer selected (for the 1% dataset) is:
                                           π(d.fname,d.lname),card:1
                                            |
                                           ⨝(m.did=d.id),card:1
                   _________________________|_________________________
                   |                                                 |
                  ⨝(a.id=c.pid),card:1                               |
  _________________|__________________                               |
  |                                  |                               |
 σ(a.lname=Spicer),card:1          ⨝(c.mid=m.mid),card:1             |
  |                           _______|________                       |
 σ(a.fname=John),card:1      |                |                      |
  |                         scan(Casts c)  scan(Movie_Director m)  scan(Director d)
scan(Actor a)

The orderJoins returns the plan with the best cost, which is computed in the helper function, computeCostandCardOfSubplan. This plan that the orderJoin returns makes sense because we would want to first join the Cast table and Movie Director table to get the condition that c.mid = m.mid, in other words get the directors matched with their cast. Then it selects fname=John and lname=Spicer from the Actor table so that the next step, joining the selection with the previous join result of Casts and Movie Directors, has a lower cost by having fewer tuples to consider. Lastly it joins the previous result with the Director table so that the condition m.did=d.id is met and then selects d.fname and d.lname. 

Question 6.2

We chose to run the following query:
  select a.fname, a.lname     
  from Actor a, Movie m, Casts c, Genre g
  where a.id=c.pid and c.mid=m.id and g.mid=m.id
  and g.genre = 'Comedy';

The query plan our optimizer selected (for the 1% dataset) is:
                         π(a.fname,a.lname),card:1
                          |
                         ⨝(g.mid=m.id),card:1
  ________________________|________________________
  |                                               |
 σ(g.genre=Comedy),card:1                      ⨝(c.mid=m.id),card:1
  |                                   ____________|_____________
  |                                   |                        |
  |                                  ⨝(a.id=c.pid),card:1      |
  |                            _______|________                |
  |                            |              |              scan(Movie m)
scan(Genre g)                scan(Actor a)  scan(Casts c)

The orderJoins returns the plan with the best cost here as well, again computed in computeCostandCardOfSubplan. This plan makes sense because we would first want to join the Cast and Actor tables (a.id = c.pid), and then join that result with the Movie table to pair up all the actors with their respective movies (c.mid = m.id). Then we join that with the selection of movies with the genre = Comedy (g.mid = m.id)--which reduces the number of tuples in the genre table to loop through--to get the resulting table of actors starring in Comedy films. Lastly the plan selects the actors' first and last names.

Discuss and justify any changes you made to the API.

We only added one method, StringHistogram.getNumTups(), to get the number of tuples. Otherwise no changes were made.

Describe any missing or incomplete elements of your code.

We don't have any missing or incomplete elements of our code, in terms of methods that needed implementation for project 3.

Describe how long you spent on the project, and whether there was anything you found particularly difficult or confusing.

The project took a few days to complete. The amount of detail we had to go into for answering questions 1 and 6 was particularly confusing, since it wasn't clear how thorough our responses were supposed to be. 


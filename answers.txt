Question 1

Step 1: simpledb.Parser.main() and simpledb.Parser.start()

simpledb.Parser.main() is the entry point for the SimpleDB system. It calls simpledb.Parser.start(). The latter performs three main actions:
- It populates the SimpleDB catalog from the catalog text file provided by the user as argument (Database.getCatalog().loadSchema(argv[0]);).
- For each table defined in the system catalog, it computes statistics over the data in the table by calling: TableStats.computeStatistics(), which then does: TableStats s = new TableStats(tableid, IOCOSTPERPAGE);
- It processes the statements submitted by the user (processNextStatement(new ByteArrayInputStream(statementBytes));)

Step 2: simpledb.Parser.processNextStatement()

This method takes two key actions:
- First, it gets a physical plan for the query by invoking handleQueryStatement((ZQuery)s);
- Then it executes the query by calling query.execute();

Step 3: simpledb.Parser.handleQueryStatement()

- This method first calls parseQueryLogicalPlan((ZQuery)s, tId) to get the logical plan for the query. 
- Then, it tries to get a physical plan from the logical plan by calling LogicalPlan.physicalPlan(tId, TableStats.getStatsMap(), explain). If there exists a physical plan, then it invokes OperatorCardinality.updateOperatorCardinality

Step 4: simpledb.Parser.parseQueryLogicalPlan()

- First, walks through tables in the FROM clause if they exist, adding each as a scan to the logical plan.
- Second, parses the WHERE clause by calling processExpression()
- Third, checks for GROUP BY fields, at most one is present
- Fourth, walks through SELECT list, picks out aggregates, and checks for query validity. If aggregates are valid, they're added to the logical plan
- Fifth, sorts the data, getting ORDER BY if exists. 

Step 5: simpledb.Parser.processExpression()

simpledb.Parser.processExpression() processes the WHERE clauses of the query, creating filter/join nodes if necessary. If there are nested subqueries, it process the subqueries as regular queries. Filter/join nodes are added to the logical plan if they exist.

Step 6: simpledb.LogicalPlan.physicalPlan()

simpledb.LogicalPlan.physicalPlan() converts the logical plan into a physical plan by 

Question 6.1

The query plan our optimizer selected (for the 1% dataset) is:
                                           π(d.fname,d.lname),card:1
                                            |
                                           ⨝(m.did=d.id),card:1
                   _________________________|_________________________
                   |                                                 |
                  ⨝(a.id=c.pid),card:1                               |
  _________________|__________________                               |
  |                                  |                               |
 σ(a.lname=Spicer),card:1          ⨝(c.mid=m.mid),card:1             |
  |                           _______|________                       |
 σ(a.fname=John),card:1      |                |                      |
  |                         scan(Casts c)  scan(Movie_Director m)  scan(Director d)
scan(Actor a)

The orderJoins returns the plan with the best cost, which is computed in the helper function, computeCostandCardOfSubplan. This plan that the orderJoin returns makes sense because we would want to first join the Cast table and Movie Director table to get the condition that c.mid = m.mid, in other words get the directors matched with their cast. Then it selects fname=John and lname=Spicer from the Actor table so that the next step, joining the selection with the previous join result of Casts and Movie Directors, has a lower cost. Lastly it joins the previous result with the Director table so that the condition m.did=d.id is met and then selects d.fname and d.lname. 

Question 6.2

We chose to run the following query:
  select a.fname, a.lname     
  from Actor a, Movie m, Casts c, Genre g
  where a.id=c.pid and c.mid=m.id and g.mid=m.id
  and g.genre = 'Comedy';

The query plan our optimizer selected (for the 1% dataset) is:
                         π(a.fname,a.lname),card:1
                          |
                         ⨝(g.mid=m.id),card:1
  ________________________|________________________
  |                                               |
 σ(g.genre=Comedy),card:1                      ⨝(c.mid=m.id),card:1
  |                                   ____________|_____________
  |                                   |                        |
  |                                  ⨝(a.id=c.pid),card:1      |
  |                            _______|________                |
  |                            |              |              scan(Movie m)
scan(Genre g)                scan(Actor a)  scan(Casts c)

The orderJoins returns the plan with the best cost here as well, again computed in computeCostandCardOfSubplan. This plan makes sense because we would first want to join the Cast and Actor tables (a.id = c.pid), and then join that result with the Movie table to pair up all the actors with their respective movies (c.mid = m.id). Then we join that with the selection of movies with the genre = Comedy (g.mid = m.id) to get the resulting table of actors starring in Comedy films. Lastly the plan selects the actors' first and last names.

Discuss and justify any changes you made to the API.

Describe any missing or incomplete elements of your code.

Describe how long you spent on the project, and whether there was anything you found particularly difficult or confusing.

The project took a few days to complete. The amount of detail we had to go into for answering questions 1 and 6 was particularly confusing, since it wasn't clear how thorough our responses were supposed to be. 

